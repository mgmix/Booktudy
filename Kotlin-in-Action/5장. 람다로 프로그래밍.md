# 5장. 람다로 프로그래밍



   - 람다 식과 멤버참조
   - 함수형 스타일로 컬렉션 다루기
   - Sequence: 지연 컬렉션 연산
   - 자바 함수형 인터페이스를 코틀린에서 사용
   - 수신 객체 지정 람다 사용



**람다 식(lamda expression) 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.**

람다를 사용하면, 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아 낼 수 있다.

수신 객체 지정 람다(lambda with receiver)  는 특별한 람다로, 람다 선언을 둘러싸고 있는 환경과는 다른 상황에서 람다 본문을 실행 할 수 있다.



## 람다 식과 멤버 참조



### 코드 블록을 함수 인자로 넘기기

이벤트가 발생하면 이 핸들러를 실행하자! 또는 데이터 구조의 모든 원소에 이 연산을 적용하자! 와 같은 생각을 코드로 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우가 자주 있다.



자바에서는 무명 내부 클래스를 통해 이런 방식을 구현 할 수 있다. 무명 내부 클래스를 사용하면 코드를 함수에 함수에 넘기거나 변수에 저장할 수 있으나 상당히 번거롭다는 문제가 있다.



**함수형 프로그래밍에서는 함수를 값 처럼 다루는 접근 방법을 택하여 이 문제를 해결!** 

클래스를 선언하고, 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접 다른 함수에 전달 할 수 있다.

람다 식을 사용하면, 함수를 선언할 필요가 없고 코드 블록을 직접 함수 인자로 전달하여 간결하게 사용 할 수 있다.



같은 구현에 대해 무명 내부 클래스의 방식과 람다 식을 이용한 방법을 살펴보자.

```java
/** Java **/
button.setOnClickListener(new OnClickListener()) { // 무명 내부 클래스를 선언하면서 그에 따른 코드가 줄줄이 따라온다.
   @Override
   public void onClick(View view) {
      // Do Something
   }
}
```



```kotlin
/** Kotlin **/
button.setOnClickListener {  /* Do Something */ } // 람다식으로 간단하게 기술 할 수있다
```



### 람다 식의 문법

```kotlin
{ x: Int, y: Int -> x + y}
     파라미터        본문
```

코틀린 람다 식은 항상 중괄호로 둘러싸여 있고, 인자 목록 주변에 괄호가 없다.  화살표(->) 가 인자 목록과 람다 본문을 구분해준다.

람다 식을 변수에 저장 하여 호출 할 수 있다.

```kotlin
val sum = { x: Int, y: Int -> x + y }
println(sum(1,2))
>>> 3
```

코트의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 `run` 을 사용한다.

run 은 인자로 받은 람다를 실행해 주는 라이브러리다. 실행 시점에 코틀린 람다 호출에는 아무 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와 비슷한 성능을 낸다.

코틀린에서는 함수 호출시 맨 뒤에 있는 인자가 람다 식이라면, 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다.

```kotlin
people.maxBy({p -> p.age})    =>   people.maxBy() {p -> p.age}
```

위 코드 처럼 람다가 어떤 함수의 유일한 인자이고, 괄호 뒤에 람다를 썼다면 호출 시에 빈 괄호를 없애도 된다.

```kotlin
people.maxBy {p -> p.age}
```



### 현재 영역에 있는 변수에 접근

람다를 함수 안에서 정의하면 함수의 파라미터 뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.

코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 final 이 아닌 변수에 접근 할 수 있고, 그 변수를 변경 할 수도 있다.

이와 같이 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수 라고 부른다.

기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다. 하지만 어떤 함수가 자신의 로컬 변수를 포함한 람다를 반환하거나

다른 변수에 저장한다면 로컬 변수의 생명 주기와 함수의 생명 주기가 달라질 수 있다. 

포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.

> **람다를 실행 시점에 표현하는 데이터 구조는, 람다에서 시작하는 모든 참조가 포함된 닫힌(Closed) 객체 그래프를 람다 코드와 함께 저장해야한다. 그런 데이터 구조를 클로저(Closure) 라고 부른다.** 함수를 쓸모 있는 1급 시민으로 만들려면 포획한 변수를 제대로 처리해야야 하며 포획한 변수를 제대로 처리하려면 클로저가 꼭 필요하다. 그래서 람다를 클로저라고 부르기도 한다

이와 같은 동작이 어떻게 가능할까?

파이널 변수를 포획한 경우 ->  람다 코드를 변수 값과 함께 저장한다.

파이널이 아닌 변수를 포획한 경우 ->  변수를 특별한 Wrapper 로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, Wrapper  에 대한 참조를 람다 코드와 함께 저장한다.



* 주의사항 : 람다를 이벤트 핸들러나, 다른 비동기적으로 실행되는 코드로 활용할 경우 함수 호출이 끝난 다음에 로컬 변수가 변경 될 수도 있다.

```kotlin
fun tryToCountButtonClicks(button: Button): Int {
	var clicks = 0
	button.onClick { clicks++ }
	return clicks
}
// tryToCountButtonClicks 가 반환 된 이후에 onClick 이 호출되기 때문에 clicks 난 항상 0을 반환
```



### 멤버 참조

람다를 사용하여 코드 블록을 다른 함수의 인자로 넘기는 방법을 살펴 보았다.

넘기려는 코드가 이미 함수로 선언된 경우는 어떻게 해야할까?

함수를 호출 하는 람다를 만들면 되지만 이렇게하면 중복이 된다.  

코틀린에서는 함수를 값으로 바꿀 수 있다. 이때 이중 콜론(::) 을 사용한다.

:: 을 사용하는 식을 멤버 참조(member reference) 라고 부른다.

멤버 참조는 프로퍼티나 메소드를 단 하나만 호출 하는 함수 값을 만들어 준다.

```kotlin
Person::age
 클래스   멤버
```

멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다. (함수 언어에서 에타 변환이라 함)

```kotlin
people.maxBy(Person::age)
people.maxBy {p -> p.age}
people.maxBy {it.age}
```

최 상위 함수나 프로퍼티를 참조 할 수도 있다.

람다가 인자가 여럿인 다른 함수한테 작업을 위임 하는 경우, 람다를 정의 하지 않고 직접 위임 함수에 대한 참조를 제공 하면 편리하다

```kotlin
val action = { person: Person, message: String -> sendEmail(person, message) }
val nextAction = ::sendEmail // -> 위의 람다 방식 대신 멤버 참조를 쓸 수 있다
```



생성자 참조(Constructor reference) 를 사용하면, 클래스 생성 작업을 연기하거나 저장해 둘 수 있다. :: 뒤에 클래스 이름을 넣어 생성자 참조를 만든다.

```kotlin
data class Person(val name: String, val age: Int)
val createPerson = ::Person
val p - createPerson("Alice", 29)
>> println(p)
Person(name=Alice, age=29)
```



## 컬렉션 함수형 API

### 필수적인 함수: filter 와 map

filter 와 map 은 컬레션 활용 시 기반이 되는 함수. filter 함수는 컬렉션에서 원치 않는 원소를 제거한다. map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.



### all, any, count, find 

컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산에 사용할 수 있다.

count 는 조건을 만족하는 원소의 개수를 반환하고, find 함수는 조건을 만족하는 첫 번째 원소를 반환한다. 

```kotlin
val canBeInClub27 = { p: Person -> p.age <= 27 } // 나이가 27살 이하인지 판단 하는 함수
val people = listOf(Perrson("Alice", 27), Person("Bob", 31))
people.all(canBeInClub27) // all 을 사용하여, 모든 원소가 이 조건을 만족하는지 확인
people.any(canBeInClub27) // 조건을 만족하는 원소가 단 하나라도 있는지 확인
```

find 는 `firstOrNull` 과 같다. 조건을 만족하는 원소가 없으면 null 을 반환 한다.

### groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경

특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 역할을 한다.



### flatMap 과 flatten 

```kotlin
class Book(val title: String, val authors: List<String>)
val books = listOf(Book("ABC", listOf("Jasper")
...
))

books.flatMap { it.authors }.toSet()
// 모든 책의 작가를 리스트 하나로 모은 뒤, toSet 으로 중복을 없애고 집합으로 만든다. 결과적으로 중복없이 모든 책의 작가를 볼 수있다
```



## 지연 계산 (Lazy) 컬렉션 연산

map 이나 filter 같은 함수는 결과 컬렉션을 즉시 생성한다. 커렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담게 된다.

`sequence` 를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄 할 수 있다.

코틀린 라이브러리 참조 문서에는, filter 와 map 이 리스트를 반환 한다고 기재 되어있다.

각 연산의 결과를 리스트로 반환하기에 두개를 연달아 사용한다면 리스트가 2개가 생성 될 것이다.

원소가 적을때는 별 문제 되지 않겠지만, 원소가 수백만 개가 되면 효율이 떨어진다.

이를 효율적으로 만들기 위해서는 각 연산이 컬렉션을 직접 사용하는 대신 시퀀스를 사용하게 해야한다.

```kotlin
people.asSequence() // -> 원본 컬렉션을 시퀀스로 변경 
	.map(Person::name)
	.filter { it.startsWith("A") }
  .toList() // -> 결과 시퀀스를 다시 리스트로 변경 
```

원소가 많은 경우에는 시퀀스를 사용하는 것이 성능에 좋다.



### 시퀀스 연산 실행 : 중간 연산, 최종 연산

시퀀스에 대한 연산은 중간 연산 과 최종 연산으로 나뉜다. 중간 연산은 다른 시퀀스를 반환하며, 이 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 안다.

최종 연산은 결과를 반환한다. 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 얻을 수 있는 컬렉션이나 원소, 숫자나 객체이다.

```kotlin
sequence.map { ... }.filter { ... }.toList()
         |         중간 연산         | 최종 연산
```

중간 연산은 항상 지연 계산 된다.

컬렉션에 대한 map 과 filter 의 동작 -> map 함수를 통해 각 원소에 대해 연산을 수행해서 새 시퀀스를 얻고, 이 시퀀스에 대해 다시 filter 를 수행한다.

시퀀스에 대한 map 과 filter 의 동작 -> 모든 연산은 각 원소에 대해 순차 적으로 적용. 첫번째 원소가 map -> filter 적용 되고 다음 원소가 처리 되는 방식

```kotlin
// 제곱 결과에서 3보다 큰 수를 찾아 첫번째 원소를 반환하는 로직 구현
listOf(1,2,3,4).asSequence().map { it * it }.find { it > 3 }
```

컬렉션을 사용하면, 위 로직에서 모든 원소를 제곱을 적용한 리스트로 변환한다. 그리고 find 를 만족하는 첫번 째 원소를 찾는다.

시퀀스를 사용하면, 최초 시퀀스로 부터 원소를 하나씩 가져와서 map 과 find 를 적용한다. 두번째 원소에서 2를 가져오면 결과를 만족하기에 이후 3과 4에 대한 연산을 처리할 필요가 없다!

이런 점에서 컬렉션의 연산의 순서나 즉시 계산(컬렉션 사용), 지연 계산(시퀀스 사용) 을 적절하게 사용해야한다.



### 시퀀스 만들기

generateSequence 함수를 사용해 시퀀스를 만들 수 있다. 이 함수는 이전의 원소를 받아 다음 원소를 계산한다. 

```kotlin
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
numbersTo100.sum() // -> sum 의 결과를 계산 할때 모든 지연 연산은 수행된다.
>>> 5050 
```



## 자바 함수형 인터페이스 활용

추상 메소드가 단 하나만 있는 인터페이스를 **함수형 인터페이스** 또는 **SAM 인터페이스** 라고 한다.

SAM 은 단일 추상 메소드 (Single Abstract Method) 라는 뜻이다. 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있도록 해준다.

람다와 무명 객체 사이에는 차이가 있다. 

**객체를 명시적으로 선언하는 경우, 메소드를 호출할 때마다 새로운 객체가 생성된다.**

람다는 다르다.

**정의가 들어있는 함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 메소드를 호출할 때마다 반복 사용 한다.**

```kotlin
postponeComputation(1000, object: Runnable { 
	override fun run() {
		println(42)
	}
})

or 

postponeComputation(1000) { println(42) } // -> 프로그램 전체에서 Runnable 의 인스턴스는 단 하나만 만들어진다

// 명시적인 object 선언을 하며, 람다와 동일한 코드
val runnable = Runnable { println(42) } // SAM 생성자, 전역변수로 컴파일 되어 단 하나의 인스턴스만 존재
fun handleComputation() {
  postponeComputation(1000, runnable) // -> 모든 handleComputation 호출에 같은 Runnable 객체 사용
}
```



### SAM 생성자 : 람다를 함수형 인터페이스로 명시적 변경

SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수이다.

컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 SAM 생성자를 사용 할 수 있다.

```kotlin
fun createAllDoneRunnable(): Runnable { 
		return Runnable { println("All Done!") }
}

createAllDoneRunnable().run()
>>> All Done!
```



## 수신 객체 지정 람다 : with 과 apply

코틀린 람다의 독특한 기능으로 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 기능이 있따.

이런 람다를 수신 객체 지정 람다(lambda with receiver) 라고 부른다.

### with 함수

어떤 객체의 이름을 반복하지 않고도 그 객체에 대한 다양한 연산을 수행

```kotlin
fun alphabet(): Sring {
		val stringBuilder = StringBuilder()
		return with(stringBuilder) { // -> 메소드를 호출하려는 수신 객체 지정, 람다 표기 관습으로 (){} 형태로 뺌
				for (letter in 'A'..'Z') {
						this.append(letter) // this 를 지정하여 stringBuilder 가 이걸 수신하여 append 를 호출 
				}
				append("Hi")
				this.toString()  // -> 람다에서 값을 반환
		}
}
```

with 함수는 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.

with 함수가 반환하는 값은 람다 코드를 실행한 결과 값이며, 그 결과는 람다 식 본문에 있는 마지막 식의 값이다.

람다의 결과 대신 수신 객체가 필요한 경우가 있다 이럴 때는 `apply`함수를 사용 하면 된다.



### apply 함수

apply 함수는 거의 with 과 같다. 유일한 차이는, apply 는 항상 자신에게 전달된 객체(수신 객체)를 반환한다는 점이다.

```kotlin
fun alphabet() = StringBuilder().apply {
	for (letter in 'A'..'Z') {
		append(letter)
	}
	append(" hi ")
}.toString()
```

apply 는 확장 함수로 정의 돼 있다.  apply의 수신 객체가 전달 받은 람다의 수신 객체가 된다.

apply 를 실행한 결과는 StringBuilder 객체 이고, 이 객체의 toString 을 호출해서 함수는 String 객체를 얻을 수 있다.

**객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화 해야 하는 경우에 유용하게 쓰인다.**





